{"posts":[{"title":"洛谷 P1880 石子合并","content":"题目 题目链接：P1880 [NOI1995] 石子合并 一道区间 DP 的典型题目。 区间 DP 特点 合并：将两个或多个部分进行整合，当然也可以反过来。 特征：能将问题分解为能两两合并的形式。 求解：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。 状态转移 下面，我们先考虑不在环上，而在一条链上的情况。 令状态 f(i,j)f(i,j)f(i,j) 表示将下标在 [i,j][i,j][i,j] 区间的元素合并起来所能获得的最大价值，则 f(1,n)f(1,n)f(1,n) 就是问题的答案。状态转移式为： f(i,j)=max⁡{f(i,k)+f(k+1,j)+cost(i,j,k)},k∈[i,j)f(i,j)=\\max\\{f(i,k)+f(k+1,j)+cost(i,j,k)\\},\\quad k\\in[i,j) f(i,j)=max{f(i,k)+f(k+1,j)+cost(i,j,k)},k∈[i,j) cost(i,j,k)cost(i,j,k)cost(i,j,k) 表示将区间 [i,k][i,k][i,k] 和 [k+1,j][k+1,j][k+1,j] 合并为 [i,j][i,j][i,j] 的代价，这里的 kkk 就是要枚举的合并点。 递推求解 使用递推法求解区间 DP 时，通常的做法是从小到大枚举区间长度。这样能保证在求解大区间时，小区间的答案已经被求解出来了。 算法模板如下，时间复杂度 O(n3)O(n^3)O(n3)。 for (int len = 2; len &lt;= n; len++) { for (int i = 1; i &lt;= n; i++) { int j = i + len - 1; for (int k = i; k &lt; j &amp;&amp; k &lt;= n; k++) { f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + cost(i, j, k)); } } } 环上的区间 DP 现在让我们回到原问题，怎么处理在环上的情况呢？ 如果是在一个长为 nnn 的环上，那么弄一条长为 2n2n2n 的链（重复一次），DP 求解后取 f(1,n),f(2,n+1),…,f(n−1,2n−1)f(1,n),f(2,n+1),\\ldots,f(n-1,2n-1)f(1,n),f(2,n+1),…,f(n−1,2n−1) 中的最优值即可。时间复杂度仍为 O(n3)O(n^3)O(n3)。 参考资料：区间 DP - OI Wiki 代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int INF = int(1e9); const int maxn = 100 + 5; int dp_min[maxn * 2][maxn * 2]; int dp_max[maxn * 2][maxn * 2]; int arr[maxn * 2]; int prefix_sum[maxn * 2]; //由于我们要把链重复一次，所以数组要开两倍大小 //预处理出前缀和 void calc_prefix_sum(int n) { prefix_sum[0] = 0; for (int i = 1; i &lt;= 2 * n - 1; i++) prefix_sum[i] = prefix_sum[i - 1] + arr[i]; } //[x, y] 的区间和 int sum(int x, int y) { return prefix_sum[y] - prefix_sum[x - 1]; } int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { int a; scanf(&quot;%d&quot;, &amp;a); arr[i] = arr[n + i] = a; } calc_prefix_sum(n); //递推求解 for (int len = 2; len &lt;= n; len++) { for (int i = 1; i &lt;= 2 * n - 1; i++) { int j = i + len - 1; int temp_min = INF; int temp_max = 0; //枚举合并点 k，计算将 [i, k] 和 [k+1, j] 合并所需的花费 for (int k = i; k &lt; j &amp;&amp; k &lt;= 2 * n - 1; k++) { temp_min = min(temp_min, dp_min[i][k] + dp_min[k + 1][j] + sum(i, j)); temp_max = max(temp_max, dp_max[i][k] + dp_max[k + 1][j] + sum(i, j)); } dp_min[i][j] = temp_min; dp_max[i][j] = temp_max; } } int ans_min = dp_min[1][n]; int ans_max = dp_max[1][n]; for (int i = 2; i &lt;= n - 1; i++) { ans_min = min(ans_min, dp_min[i][i + n - 1]); ans_max = max(ans_max, dp_max[i][i + n - 1]); } printf(&quot;%d\\n%d&quot;, ans_min, ans_max); return 0; } ","link":"https://zhb2000.github.io/post/luogu-P1880/"},{"title":"洛谷 P1862 输油管道问题","content":"题意 题目链接：P1862 输油管道问题 不难看出每个油井的 xxx 坐标是没用的，所以问题转化为如下。 代数意义：给出 nnn 个数 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​，找一个数 aaa，使得 ∑i=1n∣a−yi∣\\sum_{i=1}^n |a-y_i|∑i=1n​∣a−yi​∣ 最小。 几何意义：数轴上有 nnn 个点 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​，在数轴上放置一个点 aaa，使得线段 ay1,ay2,…,aynay_1,ay_2,\\ldots,ay_nay1​,ay2​,…,ayn​ 长度之和最小。 思路 为便于说明，假设 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​ 从小到大有序。 如果从代数意义着手，你会发现式子里既有绝对值又有和式，很难找到思路，所以应该从几何意义着手。 当 nnn 为偶数时，aaa 放在最中间两个点之间是最优的，证明如下：首先只考虑 y1y_1y1​ 和 yny_nyn​ 两个点，则点 aaa 应放在 y1y_1y1​ 和 yny_nyn​ 中间。接着再把点 y2y_2y2​ 和点 yn−1y_{n-1}yn−1​ 纳入考虑，显然 aaa 应该放在 y2y_2y2​ 和 yn−1y_{n-1}yn−1​ 中间（此时 aaa 同样也在 y1y_1y1​ 和 yny_nyn​ 中间）……依此类推即可得出结论。 当 nnn 为奇数时，aaa 放在中间那个点上是最优的，证明方法同上。 统一处理：取 y⌊n+12⌋y_{\\lfloor\\frac{n+1}{2}\\rfloor}y⌊2n+1​⌋​ 作为 aaa，或者取中位数也行。可以直接排个序取中间，也可以按快排的思想用分治法求，反正都能过。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 10000 + 5; int arr[maxn]; int solve(int n) { sort(arr + 1, arr + 1 + n); int a = arr[(n + 1) / 2]; int ans = 0; for (int i = 1; i &lt;= n; i++) ans += abs(arr[i] - a); return ans; } int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); arr[i] = y; } printf(&quot;%d&quot;, solve(n)); return 0; } ","link":"https://zhb2000.github.io/post/luogu-P1862/"}]}