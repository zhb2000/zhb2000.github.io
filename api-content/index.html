{"posts":[{"title":"洛谷 P2758 编辑距离","content":"题目 P2758 编辑距离 一道典型的线性 DP 题。 思路 状态定义 像这种线性动态规划，一种常见的状态定义方法是：用 fif_ifi​ 表示前 iii 个元素满足要求（只考虑前 iii 个元素）时的最佳答案。 因此我们很自然地想到用 f(i,j)f(i,j)f(i,j) 表示将 A[1..i]A[1..i]A[1..i] 转换为 B[1..j]B[1..j]B[1..j] 所需的最少操作次数，f(n,m)f(n,m)f(n,m) 就是问题的答案（n,mn,mn,m 分别表示字符串 A,BA,BA,B 的长度）。 状态转移 线性 DP 中，状态转移通常只需要考虑最后一点。 请设想这样一种场景，A[1..i]A[1..i]A[1..i] 经过若干次操作被改成了 B[1..j]B[1..j]B[1..j]，且最后一步操作是在 AAA 的末尾进行的。我们不由地想到，这最后一步操作只可能是以下三种： 删除 AAA 末尾的字符； 在 AAA 的末尾插入一个字符； 修改 AAA 末尾的字符。 于是我们发现，有三种策略可以把 A[1..i]A[1..i]A[1..i] 修改为 B[1..j]B[1..j]B[1..j]： 先把 A[1..i−1]A[1..i-1]A[1..i−1] 变得跟 B[1..j]B[1..j]B[1..j] 一样，再删除 AAA 末尾的字符； 先把 A[1..i]A[1..i]A[1..i] 变得跟 B[1..j−1]B[1..j-1]B[1..j−1] 一样，再在 AAA 的末尾插入一个字符； 先把 A[1..i−1]A[1..i-1]A[1..i−1] 变得跟 B[1..j−1]B[1..j-1]B[1..j−1] 一样，再修改 AAA 末尾的字符。 状态转移式： f(i,j)=min⁡{f(i−1,j)+1f(i,j−1)+1f(i−1,j−1)+{0,if Ai=Bj1,if Ai≠Bj(i&gt;0,j&gt;0)f(i,j)=\\min \\left\\{ \\begin{aligned} f(i-1,j) &amp; +1 \\\\ f(i,j-1) &amp; +1 \\\\ f(i-1,j-1) &amp; + \\left\\{ \\begin{aligned} 0 &amp; ,\\textbf{if }A_i=B_j\\\\ 1 &amp; ,\\textbf{if }A_i \\neq B_j \\end{aligned} \\right. \\end{aligned} \\right. \\quad (i&gt;0,j&gt;0) f(i,j)=min⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​f(i−1,j)f(i,j−1)f(i−1,j−1)​+1+1+{01​,if Ai​=Bj​,if Ai​​=Bj​​​(i&gt;0,j&gt;0) 边界条件 观察状态转移式，注意从左往右的下标变化，下标要么不变，要么变小，因此边界就是下标为 000 的时候： f(0,j)=jf(i,0)=if(0,0)=0\\begin{aligned} f(0,j) &amp; = j \\\\ f(i,0) &amp; = i \\\\ f(0,0) &amp; = 0 \\\\ \\end{aligned} f(0,j)f(i,0)f(0,0)​=j=i=0​ 递推顺序 由于从左往右下标要么不变，要么变小，因此递推顺序是从小到大枚举 iii 和 jjj。 在开始递推之前，应先求出所有边界的值。 代码 字符串下标从 1 开始。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 2000 + 5; char A[maxn]; char B[maxn]; int f[maxn][maxn]; int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%s%s&quot;, A + 1, B + 1); int n = strlen(A + 1); int m = strlen(B + 1); f[0][0] = 0; for (int i = 1; i &lt;= n; i++) f[i][0] = i; for (int j = 1; j &lt;= m; j++) f[0][j] = j; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) f[i][j] = min(f[i - 1][j] + 1, min(f[i][j - 1] + 1, f[i - 1][j - 1] + (A[i] == B[j] ? 0 : 1))); printf(&quot;%d&quot;, f[n][m]); return 0; } ","link":"https://zhb2000.github.io/post/luogu-P2758/"},{"title":"洛谷 P1880 石子合并","content":"题目 题目链接：P1880 [NOI1995] 石子合并 一道区间 DP 的典型题目。 区间 DP 特点 合并：将两个或多个部分进行整合，当然也可以反过来。 特征：能将问题分解为能两两合并的形式。 求解：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。 状态转移 下面，我们先考虑不在环上，而在一条链上的情况。 令状态 f(i,j)f(i,j)f(i,j) 表示将下标在 [i,j][i,j][i,j] 区间的元素合并起来所能获得的最大价值，则 f(1,n)f(1,n)f(1,n) 就是问题的答案。状态转移式为： f(i,j)=max⁡{f(i,k)+f(k+1,j)+cost(i,j,k)},k∈[i,j)f(i,j)=\\max\\{f(i,k)+f(k+1,j)+cost(i,j,k)\\},\\quad k\\in[i,j) f(i,j)=max{f(i,k)+f(k+1,j)+cost(i,j,k)},k∈[i,j) cost(i,j,k)cost(i,j,k)cost(i,j,k) 表示将区间 [i,k][i,k][i,k] 和 [k+1,j][k+1,j][k+1,j] 合并为 [i,j][i,j][i,j] 的代价，这里的 kkk 就是要枚举的合并点。 递推求解 使用递推法求解区间 DP 时，通常的做法是从小到大枚举区间长度。这样能保证在求解大区间时，小区间的答案已经被求解出来了。 算法模板如下，时间复杂度 O(n3)O(n^3)O(n3)。 for (int len = 2; len &lt;= n; len++) { for (int i = 1; i &lt;= n; i++) { int j = i + len - 1; for (int k = i; k &lt; j &amp;&amp; k &lt;= n; k++) { f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + cost(i, j, k)); } } } 环上的区间 DP 现在让我们回到原问题，怎么处理在环上的情况呢？ 如果是在一个长为 nnn 的环上，那么弄一条长为 2n2n2n 的链（重复一次），DP 求解后取 f(1,n),f(2,n+1),…,f(n−1,2n−1)f(1,n),f(2,n+1),\\ldots,f(n-1,2n-1)f(1,n),f(2,n+1),…,f(n−1,2n−1) 中的最优值即可。时间复杂度仍为 O(n3)O(n^3)O(n3)。 参考资料：区间 DP - OI Wiki 代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int INF = int(1e9); const int maxn = 100 + 5; int dp_min[maxn * 2][maxn * 2]; int dp_max[maxn * 2][maxn * 2]; int arr[maxn * 2]; int prefix_sum[maxn * 2]; //由于我们要把链重复一次，所以数组要开两倍大小 //预处理出前缀和 void calc_prefix_sum(int n) { prefix_sum[0] = 0; for (int i = 1; i &lt;= 2 * n - 1; i++) prefix_sum[i] = prefix_sum[i - 1] + arr[i]; } //[x, y] 的区间和 int sum(int x, int y) { return prefix_sum[y] - prefix_sum[x - 1]; } int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { int a; scanf(&quot;%d&quot;, &amp;a); arr[i] = arr[n + i] = a; } calc_prefix_sum(n); //递推求解 for (int len = 2; len &lt;= n; len++) { for (int i = 1; i &lt;= 2 * n - 1; i++) { int j = i + len - 1; int temp_min = INF; int temp_max = 0; //枚举合并点 k，计算将 [i, k] 和 [k+1, j] 合并所需的花费 for (int k = i; k &lt; j &amp;&amp; k &lt;= 2 * n - 1; k++) { temp_min = min(temp_min, dp_min[i][k] + dp_min[k + 1][j] + sum(i, j)); temp_max = max(temp_max, dp_max[i][k] + dp_max[k + 1][j] + sum(i, j)); } dp_min[i][j] = temp_min; dp_max[i][j] = temp_max; } } int ans_min = dp_min[1][n]; int ans_max = dp_max[1][n]; for (int i = 2; i &lt;= n - 1; i++) { ans_min = min(ans_min, dp_min[i][i + n - 1]); ans_max = max(ans_max, dp_max[i][i + n - 1]); } printf(&quot;%d\\n%d&quot;, ans_min, ans_max); return 0; } ","link":"https://zhb2000.github.io/post/luogu-P1880/"},{"title":"洛谷 P1862 输油管道问题","content":"题意 题目链接：P1862 输油管道问题 不难看出每个油井的 xxx 坐标是没用的，所以问题转化为如下。 代数意义：给出 nnn 个数 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​，找一个数 aaa，使得 ∑i=1n∣a−yi∣\\sum_{i=1}^n |a-y_i|∑i=1n​∣a−yi​∣ 最小。 几何意义：数轴上有 nnn 个点 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​，在数轴上放置一个点 aaa，使得线段 ay1,ay2,…,aynay_1,ay_2,\\ldots,ay_nay1​,ay2​,…,ayn​ 长度之和最小。 思路 为便于说明，假设 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​ 从小到大有序。 如果从代数意义着手，你会发现式子里既有绝对值又有和式，很难找到思路，所以应该从几何意义着手。 当 nnn 为偶数时，aaa 放在最中间两个点之间是最优的，证明如下：首先只考虑 y1y_1y1​ 和 yny_nyn​ 两个点，则点 aaa 应放在 y1y_1y1​ 和 yny_nyn​ 中间。接着再把点 y2y_2y2​ 和点 yn−1y_{n-1}yn−1​ 纳入考虑，显然 aaa 应该放在 y2y_2y2​ 和 yn−1y_{n-1}yn−1​ 中间（此时 aaa 同样也在 y1y_1y1​ 和 yny_nyn​ 中间）……依此类推即可得出结论。 当 nnn 为奇数时，aaa 放在中间那个点上是最优的，证明方法同上。 统一处理：取 y⌊n+12⌋y_{\\lfloor\\frac{n+1}{2}\\rfloor}y⌊2n+1​⌋​ 作为 aaa，或者取中位数也行。可以直接排个序取中间，也可以按快排的思想用分治法求，反正都能过。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 10000 + 5; int arr[maxn]; int solve(int n) { sort(arr + 1, arr + 1 + n); int a = arr[(n + 1) / 2]; int ans = 0; for (int i = 1; i &lt;= n; i++) ans += abs(arr[i] - a); return ans; } int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); arr[i] = y; } printf(&quot;%d&quot;, solve(n)); return 0; } ","link":"https://zhb2000.github.io/post/luogu-P1862/"}]}