{"posts":[{"title":"用向量叉乘求直线交点","content":" 求解方法 两个技巧： 用向量来表示点，则可以用向量加法来表示点的平移。 用点和向量来表示直线，这样可以处理斜率无穷大的情况。 如图所示，有两条直线交于点 III。我们用点 p1p_1p1​ 和向量 v⃗1\\vec v_1v1​ 来表示直线 1，用点 p2p_2p2​ 和向量 v⃗2\\vec v_2v2​ 来表示直线 2。 把点看成向量，则有 I=p1+tv1\\mathbf I=\\mathbf p_1+t\\mathbf v_1I=p1​+tv1​（用向量加法表示点的平移），现在我们的任务就是求出标量 ttt。所谓用向量叉乘来求直线交点，就是利用 Ip2→×v⃗2=0⃗\\overrightarrow{Ip_2}\\times\\vec v_2=\\vec 0Ip2​​×v2​=0（两向量平行）这个式子求出 ttt。 在开始推导之前，先复习一下向量叉乘的几条运算规律： 加法的左分配律：a×(b+c)=a×b+a×c\\mathbf{a} \\times (\\mathbf{b} + \\mathbf{c}) = \\mathbf{a} \\times \\mathbf{b} + \\mathbf{a} \\times \\mathbf{c}a×(b+c)=a×b+a×c 加法的右分配律：(a+b)×c=a×c+b×c(\\mathbf{a} + \\mathbf{b}) \\times \\mathbf{c} = \\mathbf{a} \\times \\mathbf{c} + \\mathbf{b} \\times \\mathbf{c}(a+b)×c=a×c+b×c 标量乘法：(λa)×b=λ(a×b)=a×(λb)(\\lambda\\mathbf{a})\\times\\mathbf{b} = \\lambda(\\mathbf{a}\\times\\mathbf{b}) = \\mathbf{a}\\times(\\lambda\\mathbf{b})(λa)×b=λ(a×b)=a×(λb) 下面我们来求解标量 ttt，推导过程如下： (p2−I)×v2=0(p2−(p1+tv1))×v2=0(p2−p1)×v2−tv1×v2=0(p2−p1)×v2=t(v1×v2)t=∣(p2−p1)×v2∣∣v1×v2∣\\begin{array}{rcl} (\\mathbf{p}_2 - \\mathbf{I}) \\times \\mathbf{v}_2 &amp;=&amp; \\mathbf{0}\\\\ (\\mathbf{p}_2 - (\\mathbf{p}_1 + t\\mathbf{v}_1)) \\times \\mathbf{v}_2 &amp;=&amp; \\mathbf{0}\\\\ (\\mathbf{p}_2 - \\mathbf{p}_1) \\times \\mathbf{v}_2 - t\\mathbf{v}_1 \\times \\mathbf{v}_2 &amp;=&amp; \\mathbf{0}\\\\ (\\mathbf{p}_2 - \\mathbf{p}_1) \\times \\mathbf{v}_2 &amp;=&amp; t(\\mathbf{v}_1 \\times \\mathbf{v}_2)\\\\ t &amp;=&amp; \\frac{|(\\mathbf{p}_2 - \\mathbf{p}_1) \\times \\mathbf{v}_2|}{|\\mathbf{v}_1 \\times \\mathbf{v}_2|} \\end{array} (p2​−I)×v2​(p2​−(p1​+tv1​))×v2​(p2​−p1​)×v2​−tv1​×v2​(p2​−p1​)×v2​t​=====​000t(v1​×v2​)∣v1​×v2​∣∣(p2​−p1​)×v2​∣​​ 好了，现在我们求出了标量 ttt，接下来用 I=p1+tv1\\mathbf I=\\mathbf p_1+t\\mathbf v_1I=p1​+tv1​ 这个式子计算出交点 III 的坐标即可。 顺便一提，这种“将点和向量统一表示”的思想在计算机图形学中有很重要的应用，即齐次坐标。 代码 首先我们需要写一个向量类。 注意，代码中的 cross 函数求的是向量积的模，所以返回的是个标量。 //二维向量 struct Vec { double x, y; Vec() = default; Vec(double x, double y) : x(x), y(y) {} double len2() const { return x * x + y * y; } double len() const { return sqrt(len2()); } Vec operator+(const Vec &amp;b) const { return Vec(x + b.x, y + b.y); } Vec operator-(const Vec &amp;b) const { return Vec(x - b.x, y - b.y); } Vec operator*(double t) const { return Vec(x * t, y * t); } Vec operator/(double t) const { return Vec(x / t, y / t); } Vec operator-() const { return Vec(-x, -y); } }; //向量积的模 double cross(const Vec &amp;a, const Vec &amp;b) { return a.x * b.y - b.x * a.y; } 求解两直线交点的代码。代码相当简洁，而且可以应对包括直线斜率无穷大在内的所有情况。 //求解两直线交点 //p1、v1 用于表示直线 1，p2、v2 用于表示直线 2 Vec intersection(const Vec &amp;p1, const Vec &amp;v1, const Vec &amp;p2, const Vec &amp;v2) { double t = cross((p2 - p1), v2) / cross(v1, v2); return p1 + v1 * t; } ","link":"https://zhb2000.github.io/post/vector-cross-product-solve-intersection/"},{"title":"C++默认参数静态绑定","content":"先来看这样一段代码 class Base { public: virtual void print(int a = 1) const { std::cout &lt;&lt; &quot;Base &quot; &lt;&lt; a &lt;&lt; &quot;\\n&quot;; } }; class Derived : public Base { public: virtual void print(int a = 2) const override { std::cout &lt;&lt; &quot;Derived &quot; &lt;&lt; a &lt;&lt; &quot;\\n&quot;; } }; 请问：若按如下方式调用，会输出什么？ Base *p = new Derived(); p-&gt;print(); 答案：输出 Derived 1（而非 Base 1 或 Derived 2）。 原因： 虚函数动态绑定，在运行时根据对象的实际类型决定调用哪个函数，因此这里调用的函数为 Base::print。 默认实参静态绑定，在编译期根据指针的声明类型决定默认实参的值，因此这里的 p-&gt;print() 相当于 p-&gt;print(1)。 因此，重写基类函数时不要重新定义函数的默认参数，以避免出现上文中的坑。 参考资料： Effective C++ item 37: Never Redefine a Function's Inherited Default Parameter Value 默认实参 - cppreference.com ","link":"https://zhb2000.github.io/post/cpp-default-arguments/"},{"title":"Edit Step Ladders - UVA 10029","content":"题意 题目链接（Virtual Judge）：Edit Step Ladders - UVA 10029 题意： 如果单词 xxx 能通过添加、删除或修改一个字母变换为单词 yyy，则称单词 xxx 到单词 yyy 的变换为一个 edit step。 Edit step ladder 指的是一个按字典序排列的单词序列 w1,w2,…,wnw_1,w_2,\\ldots,w_nw1​,w2​,…,wn​，每个 wi+1w_{i+1}wi+1​ 都由 wiw_iwi​ 经一个 edit step 变换而来。 给出一个按字典序排列的单词序列，问其中符合 edit step ladder 要求的最长子序列的长度。 思路 虽然这题目又是字典序，又是子序列什么的，但其实跟字符串没多少关系，做法是建图跑最长路，将单词视为图节点，单词之间的变换视为有向边。想出建图这个思路后，剩下的就好办了。 首先是怎样建图的问题。如果采用枚举所有单词对的方法，时间复杂度 O(n2)O(n^2)O(n2)，很可能会超时。我们注意到单词的长度非常短，所以不妨换一种思路：对于一个单词，枚举它能变换出的所有单词，这样便能实现 O(n)O(n)O(n) 建图。 具体做法如下：用哈希表保存单词及其对应下标。对于一个单词，枚举它经过一步 edit step 变换后的所有单词，看变换后在不在哈希表里。如果在，且下标大于当前单词（为了满足字典序要求），则构造一条有向边。 接着是怎样求解最长路的问题。显然此图是个有向无环图，所以我们可以用动态规划的方法 O(n)O(n)O(n) 求出最长路。 用 step(u)\\mathrm{step}(u)step(u) 表示从 uuu 出发的最长路的长度（路径上的节点数），状态转移方程如下： step(u)={1if u is a leaf1+max⁡{step(v)∣(u,v)∈E}otherwise\\mathrm{step}(u)=\\left\\{ \\begin{array}{ll} 1 &amp; \\text{if}\\; u \\;\\text{is a leaf} \\\\ 1+\\max\\{\\mathrm{step}(v) \\mid (u,v)\\in E\\} &amp; \\text{otherwise} \\\\ \\end{array} \\right. step(u)={11+max{step(v)∣(u,v)∈E}​ifuis a leafotherwise​ 代码 注意：输出答案后还要再输出一个换行符，否则 UVA 会判你 WA（而不是 PE），非常的毒瘤。 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;unordered_map&gt; #include &lt;algorithm&gt; #include &lt;cassert&gt; using namespace std; const int maxn = int(25000 + 5); string word_arr[maxn]; unordered_map&lt;string, int&gt; word_dict; vector&lt;int&gt; G[maxn]; int step_arr[maxn]; // 将 s 的第 i 个字符换成 ch string change_letter(const string &amp;s, int i, char ch) { string ret = s; ret[i] = ch; return ret; } // 将 s 的第 i 个字符移除 string remove_letter(const string &amp;s, int i) { string ret; int len = int(s.length()); ret.reserve(len - 1); for (int j = 0; j &lt; len; j++) if (j != i) ret.push_back(s[j]); return ret; } // 在 s 的第 i 个字符前面插入字符 ch string insert_letter(const string &amp;s, int i, char ch) { string ret; int len = int(s.length()); ret.reserve(len + 1); if (i == len) { ret = s; ret.push_back(ch); return ret; } for (int j = 0; j &lt; len; j++) { if (j == i) ret.push_back(ch); ret.push_back(s[j]); } return ret; } // 添加有向边 u -&gt; v void add_edge(int u, int v) { G[u].push_back(v); } // 从点 u 出发的最长路的长度 int longest_step(int u) { if (step_arr[u] &gt; 0) return step_arr[u]; int max_son_step = 0; for (int v : G[u]) max_son_step = max(max_son_step, longest_step(v)); step_arr[u] = max_son_step + 1; return step_arr[u]; } int main() { ios_base::sync_with_stdio(false); string word; int index = 1; while (cin &gt;&gt; word) { word_arr[index] = word; word_dict[word] = index; index++; } int n = index - 1; for (int u = 1; u &lt;= n; u++) { const string &amp;cur = word_arr[u]; int len = int(cur.length()); // 修改字符 for (int i = 0; i &lt; len; i++) { for (char ch = cur[i] + 1; ch &lt;= 'z'; ch++) { string gen = change_letter(cur, i, ch); if (word_dict.count(gen) &gt; 0) { int v = word_dict[gen]; assert(u &lt; v); add_edge(u, v); } } } // 移除字符 for (int i = 0; i &lt; len; i++) { string gen = remove_letter(cur, i); if (word_dict.count(gen) &gt; 0) { int v = word_dict[gen]; if (u &lt; v) add_edge(u, v); } } // 插入字符 for (int i = 0; i &lt;= len; i++) { for (char ch = 'a'; ch &lt;= 'z'; ch++) { string gen = insert_letter(cur, i, ch); if (word_dict.count(gen) &gt; 0) { int v = word_dict[gen]; if (u &lt; v) add_edge(u, v); } } } } int ans = 0; for (int u = 1; u &lt;= n; u++) ans = max(ans, longest_step(u)); cout &lt;&lt; ans &lt;&lt; '\\n'; return 0; } ","link":"https://zhb2000.github.io/post/UVA-10029/"},{"title":"三种方法求解最大子区间和：DP、前缀和、分治","content":"题目 洛谷：P1115 最大子段和 LeetCode：最大子序和 给出一个长度为 nnn 的序列 aaa，选出其中连续且非空的一段使得这段和最大。 挺经典的一道题目，下面分别介绍 O(n)O(n)O(n) 的 DP 做法、前缀和做法，以及 O(nlog⁡n)O(n\\log n)O(nlogn) 的分治做法。 DP 做法 用 did_idi​ 表示结尾为位置 iii 的最大区间和，则有 di=max⁡(di−1,0)+aid_i=\\max(d_{i-1},0)+a_i di​=max(di−1​,0)+ai​ 问题的答案即为 max⁡{di∣i∈[1,n]}\\max\\{d_i \\mid i\\in[1,n]\\}max{di​∣i∈[1,n]}。 编写代码时不需要开 ddd 数组，用变量 last_d 记录 di−1d_{i-1}di−1​，变量 ans 记录 max⁡{di}\\max\\{d_i\\}max{di​}，并在扫描时动态更新即可。 时间复杂度 O(n)O(n)O(n)，空间复杂度 O(1)O(1)O(1)。 核心代码如下： maxn = int(2e5 + 5) arr = [0 for _ in range(maxn)] # 从下标 1 开始存 # 输入过程略…… ans = None last_d = 0 for i in range(1, n + 1): temp_ans = max(last_d, 0) + arr[i] if ans is None or temp_ans &gt; ans: ans = temp_ans last_d = temp_ans print(ans) 前缀和做法 将数列前 nnn 项的和记为 sumnsum_nsumn​： sumn=∑i=1naisum_n=\\sum_{i=1}^n a_i sumn​=i=1∑n​ai​ 可以用前缀和快速求区间和： ∑i=xyai=sumy−sumx−1\\sum_{i=x}^y a_i = sum_y - sum_{x-1} i=x∑y​ai​=sumy​−sumx−1​ 用 did_idi​ 表示结尾为位置 iii 的最大区间和，则有 di=sumi−min⁡{sumj∣j&lt;i}d_i=sum_i-\\min\\{sum_j \\mid j&lt;i\\} di​=sumi​−min{sumj​∣j&lt;i} 问题的答案即为 max⁡{di∣i∈[1,n]}\\max\\{d_i \\mid i \\in [1,n]\\}max{di​∣i∈[1,n]}。 编写代码时只需要开前缀和数组，无需开 ddd 数组，用变量 cur_min_pre_sum 记录 min⁡{sumj}\\min\\{sum_j\\}min{sumj​}，变量 ans 记录 max⁡{di}\\max\\{d_i\\}max{di​}，并动态维护即可。 时间复杂度 O(n)O(n)O(n)，空间复杂度 O(n)O(n)O(n)。 核心代码如下： maxn = int(2e5 + 5) arr = [0 for _ in range(maxn)] # 原数组，从下标 1 开始存 pre_sum = [0 for _ in range(maxn)] # 前缀和数组 # 输入过程略…… # 预处理前缀和 for i in range(1, n + 1): pre_sum[i] = pre_sum[i - 1] + arr[i] cur_min_pre_sum = 0 ans = None for i in range(1, n + 1): temp_ans = pre_sum[i] - cur_min_pre_sum if ans is None or temp_ans &gt; ans: ans = temp_ans cur_min_pre_sum = min(cur_min_pre_sum, pre_sum[i]) print(ans) 分治做法 若有一区间 [start,stop)[start,stop)[start,stop)，区间中点为 midmidmid，其最大子段和对应的子区间为 [i,j)[i,j)[i,j)，则 [i,j)[i,j)[i,j) 只有以下三种情况： [i,j)[i,j)[i,j) 完全在左子区间 [start,mid)[start,mid)[start,mid) 内； [i,j)[i,j)[i,j) 完全在右子区间 [mid,stop)[mid,stop)[mid,stop) 内； [i,j)[i,j)[i,j) 横跨中点 midmidmid。 求出这三种情况下的值，取最大的即可。 前两种情况可通过递归求解，求解第三种情况需要一点技巧，方法是从中点出发分别向左右两边延伸。 时间复杂度 O(nlog⁡n)O(n\\log n)O(nlogn)。 核心代码如下： maxn = int(2e5 + 5) arr = [0 for _ in range(maxn)] # 从下标 1 开始存 # 从位置 mid - 1 开始向左延伸的最大区间和 # 注：左子区间 [start, mid) def mid_lmax(start: int, mid: int) -&gt; int: ans = None cur_sum = 0 for i in range(mid - 1, start - 1, -1): cur_sum += arr[i] if ans is None or cur_sum &gt; ans: ans = cur_sum return ans # 从位置 mid 开始向右延伸的最大区间和 # 注：右子区间 [mid, stop) def mid_rmax(mid: int, stop: int) -&gt; int: ans = None cur_sum = 0 for i in range(mid, stop): cur_sum += arr[i] if ans is None or cur_sum &gt; ans: ans = cur_sum return ans # [start, stop) 的最大子区间和 def solve(start: int, stop: int) -&gt; int: if stop - start == 1: return arr[start] mid = (start + stop) // 2 only_lmax = solve(start, mid) # 完全在左子区间内 only_rmax = solve(mid, stop) # 完全在右子区间内 span_max = mid_lmax(start, mid) + mid_rmax(mid, stop) # 横跨中点 return max(only_lmax, only_rmax, span_max) ","link":"https://zhb2000.github.io/post/maximum-subarray-sum/"},{"title":"洛谷 P2758 编辑距离","content":"题目 P2758 编辑距离 一道典型的线性 DP 题。 思路 状态定义 像这种线性动态规划，一种常见的状态定义方法是：用 fif_ifi​ 表示前 iii 个元素满足要求（只考虑前 iii 个元素）时的最佳答案。 因此我们很自然地想到用 f(i,j)f(i,j)f(i,j) 表示将 A[1..i]A[1..i]A[1..i] 转换为 B[1..j]B[1..j]B[1..j] 所需的最少操作次数，f(n,m)f(n,m)f(n,m) 就是问题的答案（n,mn,mn,m 分别表示字符串 A,BA,BA,B 的长度）。 状态转移 线性 DP 中，状态转移通常只需要考虑最后一点。 请设想这样一种场景，A[1..i]A[1..i]A[1..i] 经过若干次操作被改成了 B[1..j]B[1..j]B[1..j]，且最后一步操作是在 AAA 的末尾进行的。我们不由地想到，这最后一步操作只可能是以下三种： 删除 AAA 末尾的字符； 在 AAA 的末尾插入一个字符； 修改 AAA 末尾的字符。 于是我们发现，有三种策略可以把 A[1..i]A[1..i]A[1..i] 修改为 B[1..j]B[1..j]B[1..j]： 先把 A[1..i−1]A[1..i-1]A[1..i−1] 变得跟 B[1..j]B[1..j]B[1..j] 一样，再删除 AAA 末尾的字符； 先把 A[1..i]A[1..i]A[1..i] 变得跟 B[1..j−1]B[1..j-1]B[1..j−1] 一样，再在 AAA 的末尾插入一个字符； 先把 A[1..i−1]A[1..i-1]A[1..i−1] 变得跟 B[1..j−1]B[1..j-1]B[1..j−1] 一样，再修改 AAA 末尾的字符。 状态转移式： f(i,j)=min⁡{f(i−1,j)+1f(i,j−1)+1f(i−1,j−1)+{0,if Ai=Bj1,if Ai≠Bj(i&gt;0,j&gt;0)f(i,j)=\\min \\left\\{ \\begin{aligned} f(i-1,j) &amp; +1 \\\\ f(i,j-1) &amp; +1 \\\\ f(i-1,j-1) &amp; + \\left\\{ \\begin{aligned} 0 &amp; ,\\textbf{if }A_i=B_j\\\\ 1 &amp; ,\\textbf{if }A_i \\neq B_j \\end{aligned} \\right. \\end{aligned} \\right. \\quad (i&gt;0,j&gt;0) f(i,j)=min⎩⎪⎪⎪⎪⎨⎪⎪⎪⎪⎧​f(i−1,j)f(i,j−1)f(i−1,j−1)​+1+1+{01​,if Ai​=Bj​,if Ai​​=Bj​​​(i&gt;0,j&gt;0) 边界条件 观察状态转移式，注意从左往右的下标变化，下标要么不变，要么变小，因此边界就是下标为 000 的时候： f(0,j)=jf(i,0)=if(0,0)=0\\begin{aligned} f(0,j) &amp; = j \\\\ f(i,0) &amp; = i \\\\ f(0,0) &amp; = 0 \\\\ \\end{aligned} f(0,j)f(i,0)f(0,0)​=j=i=0​ 递推顺序 由于从左往右下标要么不变，要么变小，因此递推顺序是从小到大枚举 iii 和 jjj。 在开始递推之前，应先求出所有边界的值。 代码 字符串下标从 1 开始。 #include &lt;cstdio&gt; #include &lt;cstring&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 2000 + 5; char A[maxn]; char B[maxn]; int f[maxn][maxn]; int main() { #ifdef LOCAL freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin); freopen(&quot;out.txt&quot;, &quot;w&quot;, stdout); #endif scanf(&quot;%s%s&quot;, A + 1, B + 1); int n = strlen(A + 1); int m = strlen(B + 1); f[0][0] = 0; for (int i = 1; i &lt;= n; i++) f[i][0] = i; for (int j = 1; j &lt;= m; j++) f[0][j] = j; for (int i = 1; i &lt;= n; i++) for (int j = 1; j &lt;= m; j++) f[i][j] = min(f[i - 1][j] + 1, min(f[i][j - 1] + 1, f[i - 1][j - 1] + (A[i] == B[j] ? 0 : 1))); printf(&quot;%d&quot;, f[n][m]); return 0; } ","link":"https://zhb2000.github.io/post/luogu-P2758/"},{"title":"洛谷 P1880 石子合并","content":"题目 题目链接：P1880 [NOI1995] 石子合并 一道区间 DP 的典型题目。 区间 DP 特点 合并：将两个或多个部分进行整合，当然也可以反过来。 特征：能将问题分解为能两两合并的形式。 求解：对整个问题设最优值，枚举合并点，将问题分解为左右两个部分，最后合并两个部分的最优值得到原问题的最优值。 状态转移 下面，我们先考虑不在环上，而在一条链上的情况。 令状态 f(i,j)f(i,j)f(i,j) 表示将下标在 [i,j][i,j][i,j] 区间的元素合并起来所能获得的最大价值，则 f(1,n)f(1,n)f(1,n) 就是问题的答案。状态转移式为： f(i,j)=max⁡{f(i,k)+f(k+1,j)+cost(i,j,k)},k∈[i,j)f(i,j)=\\max\\{f(i,k)+f(k+1,j)+cost(i,j,k)\\},\\quad k\\in[i,j) f(i,j)=max{f(i,k)+f(k+1,j)+cost(i,j,k)},k∈[i,j) cost(i,j,k)cost(i,j,k)cost(i,j,k) 表示将区间 [i,k][i,k][i,k] 和 [k+1,j][k+1,j][k+1,j] 合并为 [i,j][i,j][i,j] 的代价，这里的 kkk 就是要枚举的合并点。 递推求解 使用递推法求解区间 DP 时，通常的做法是从小到大枚举区间长度。这样能保证在求解大区间时，小区间的答案已经被求解出来了。 算法模板如下，时间复杂度 O(n3)O(n^3)O(n3)。 for (int len = 2; len &lt;= n; len++) { for (int i = 1; i &lt;= n; i++) { int j = i + len - 1; for (int k = i; k &lt; j &amp;&amp; k &lt;= n; k++) { f[i][j] = max(f[i][j], f[i][k] + f[k + 1][j] + cost(i, j, k)); } } } 环上的区间 DP 现在让我们回到原问题，怎么处理在环上的情况呢？ 如果是在一个长为 nnn 的环上，那么弄一条长为 2n2n2n 的链（重复一次），DP 求解后取 f(1,n),f(2,n+1),…,f(n−1,2n−1)f(1,n),f(2,n+1),\\ldots,f(n-1,2n-1)f(1,n),f(2,n+1),…,f(n−1,2n−1) 中的最优值即可。时间复杂度仍为 O(n3)O(n^3)O(n3)。 参考资料：区间 DP - OI Wiki 代码 #include &lt;cstdio&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int INF = int(1e9); const int maxn = 100 + 5; int dp_min[maxn * 2][maxn * 2]; int dp_max[maxn * 2][maxn * 2]; int arr[maxn * 2]; int prefix_sum[maxn * 2]; //由于我们要把链重复一次，所以数组要开两倍大小 //预处理出前缀和 void calc_prefix_sum(int n) { prefix_sum[0] = 0; for (int i = 1; i &lt;= 2 * n - 1; i++) prefix_sum[i] = prefix_sum[i - 1] + arr[i]; } //[x, y] 的区间和 int sum(int x, int y) { return prefix_sum[y] - prefix_sum[x - 1]; } int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { int a; scanf(&quot;%d&quot;, &amp;a); arr[i] = arr[n + i] = a; } calc_prefix_sum(n); //递推求解 for (int len = 2; len &lt;= n; len++) { for (int i = 1; i &lt;= 2 * n - 1; i++) { int j = i + len - 1; int temp_min = INF; int temp_max = 0; //枚举合并点 k，计算将 [i, k] 和 [k+1, j] 合并所需的花费 for (int k = i; k &lt; j &amp;&amp; k &lt;= 2 * n - 1; k++) { temp_min = min(temp_min, dp_min[i][k] + dp_min[k + 1][j] + sum(i, j)); temp_max = max(temp_max, dp_max[i][k] + dp_max[k + 1][j] + sum(i, j)); } dp_min[i][j] = temp_min; dp_max[i][j] = temp_max; } } int ans_min = dp_min[1][n]; int ans_max = dp_max[1][n]; for (int i = 2; i &lt;= n - 1; i++) { ans_min = min(ans_min, dp_min[i][i + n - 1]); ans_max = max(ans_max, dp_max[i][i + n - 1]); } printf(&quot;%d\\n%d&quot;, ans_min, ans_max); return 0; } ","link":"https://zhb2000.github.io/post/luogu-P1880/"},{"title":"洛谷 P1862 输油管道问题","content":"题意 题目链接：P1862 输油管道问题 不难看出每个油井的 xxx 坐标是没用的，所以问题转化为如下。 代数意义：给出 nnn 个数 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​，找一个数 aaa，使得 ∑i=1n∣a−yi∣\\sum_{i=1}^n |a-y_i|∑i=1n​∣a−yi​∣ 最小。 几何意义：数轴上有 nnn 个点 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​，在数轴上放置一个点 aaa，使得线段 ay1,ay2,…,aynay_1,ay_2,\\ldots,ay_nay1​,ay2​,…,ayn​ 长度之和最小。 思路 为便于说明，假设 y1,y2,…,yny_1,y_2,\\ldots,y_ny1​,y2​,…,yn​ 从小到大有序。 如果从代数意义着手，你会发现式子里既有绝对值又有和式，很难找到思路，所以应该从几何意义着手。 当 nnn 为偶数时，aaa 放在最中间两个点之间是最优的，证明如下：首先只考虑 y1y_1y1​ 和 yny_nyn​ 两个点，则点 aaa 应放在 y1y_1y1​ 和 yny_nyn​ 中间。接着再把点 y2y_2y2​ 和点 yn−1y_{n-1}yn−1​ 纳入考虑，显然 aaa 应该放在 y2y_2y2​ 和 yn−1y_{n-1}yn−1​ 中间（此时 aaa 同样也在 y1y_1y1​ 和 yny_nyn​ 中间）……依此类推即可得出结论。 当 nnn 为奇数时，aaa 放在中间那个点上是最优的，证明方法同上。 统一处理：取 y⌊n+12⌋y_{\\lfloor\\frac{n+1}{2}\\rfloor}y⌊2n+1​⌋​ 作为 aaa，或者取中位数也行。可以直接排个序取中间，也可以按快排的思想用分治法求，反正都能过。 代码 #include &lt;cstdio&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; const int maxn = 10000 + 5; int arr[maxn]; int solve(int n) { sort(arr + 1, arr + 1 + n); int a = arr[(n + 1) / 2]; int ans = 0; for (int i = 1; i &lt;= n; i++) ans += abs(arr[i] - a); return ans; } int main() { int n; scanf(&quot;%d&quot;, &amp;n); for (int i = 1; i &lt;= n; i++) { int x, y; scanf(&quot;%d%d&quot;, &amp;x, &amp;y); arr[i] = y; } printf(&quot;%d&quot;, solve(n)); return 0; } ","link":"https://zhb2000.github.io/post/luogu-P1862/"}]}